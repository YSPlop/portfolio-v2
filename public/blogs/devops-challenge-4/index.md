# Continuous Integration with CodeBuild

> Credit to nextwork.org for assisting with instructions and content

**Author:** Yukash Sivaraj  
**Email:** sivarajyukash@gmail.com

---

![Image](http://learn.nextwork.org/merry_vermilion_zany_llama/uploads/aws-devops-codebuild-updated_35588a47)

---

## Introducing Today's Project!

I will demonstrate how to use AWSCodebuild from scratch to automate the builld process in the CI/CD pipeline. Building means compressing our web app's files into a single compressed file (like a zip file) that we can later deploy. This project is just going to focus on CodeBulid and creating that compressed file automatically. Deploying it comes in the next blog!

### Key tools and concepts

Services I used were AWS CodeBuild, AWS CodeArtifact, S3 buckets, EC2 instances and IAM. Key concepts I learn include:

* **AWS CodeBuild:** Learned to set up and use CodeBuild for automating code compilation, testing, and packaging.
* **CodeArtifact Integration:** Understood how to integrate CodeBuild with CodeArtifact for secure package management.
* **IAM Roles for Services:** Gained knowledge on creating and assigning specific IAM roles for AWS services to interact securely.
* **Buildspec.yml Mastery:** Learned to write custom `buildspec.yml` files to define build commands and phases.
* **Automated Testing:** Implemented automated tests within the build process to ensure code quality.

### Project reflection

This project took me approximately 3 hours. The most challenging part was the patience to wait for the build. It was most rewarding to watch the build run the test and have a successful zip in my S3 bucket.

This project is part four of a series of DevOps projects where I'm building a CI/CD pipeline! I'll be working on the next project in 24 hrs!

---

## Setting up a CodeBuild Project

CodeBuild is continous integration service, which means it is a quality control checkpoint for your code. This will help you catch and fix issues early and often. Engineering teams use it because you dont have to manually setup and manage any build servers ourselves and we only pay for the build time we use. 

I configured my CodeBuild project to use GitHub as the source provider, so it knows exactly where to find the codebase that needs to be built and compiled.

![Image](http://learn.nextwork.org/merry_vermilion_zany_llama/uploads/aws-devops-codebuild-updated_fewgrhte)

---

## Connecting CodeBuild with GitHub

Thyere are multiple credential types for Github, like 
1. **Github App**: where AWS manages the application and connection, reducing the need for us to handle tokens or keys directly. 
2. **Personal access token**: This method uses a personal access token generated from your github account. This is straightforward but it requires for us to manage and rotate tokens, which can be less secure and requires more work.
3. **OAuthApp**: This involves setting up an OAuth application in GitHub and configuring CodeConnections to use it. It provides a more granular control over permissions but is more complex to set up compared to GitHub App.

I used Github App because it seemed to be the most secure and efficient way to go about linking the account.

The service that helped connect Github to AWS CodeBuild is called AWS CodeConnections. AWS CodeConnections is like a secure bridge between AWS and your external code repositories. Instead of dealing with the headache of managing API keys, tokens (like GitHub's Personal Access Tokens!), or SSH credentials, CodeConnections handles all that authentication complexity for you - so you can focus on building your application.

![Image](http://learn.nextwork.org/merry_vermilion_zany_llama/uploads/aws-devops-codebuild-updated_a7c98e2d)

---

## CodeBuild Configurations

### Environment

My CodeBuild project's Environment configuration means that we would have resources to build on-demand with an AWS managed image for EC2 instances, the managed image would be for java:correto8.

### Artifacts

Build artifacts are the packaged output files generated by the build process, such as compiled code, dependencies, configuration files, or container images. They're important because they represent the deployable components of an application, ensuring consistency, version control, and traceability across development, staging, and production environments.

My build process will create versioned application bundles, such as .zip files for Lambda functions, .jar files for Java applications, .tar.gz archives for static sites or microservices, or Docker image metadata. These artifacts are the result of automated build tools like AWS CodeBuild, Jenkins, or GitHub Actions running unit tests, resolving dependencies, and packaging code.

To store them, I created an Amazon S3 bucket specifically configured for build artifact storage.

### Packaging

When setting up CodeBuild, I also chose to package artifacts in a zip file because:
1. it is easier to manage one file and share one file than manage many. 
2. A zip file also takes less space.

### Monitoring

For monitoring, I enabled CloudWatch Logs, which is used to monitor the run time of the project. CloudWatch will record everything that happens during the build process, including the commands that are run, the output of those commands, and any errors that occur. This is incredibly useful for debugging and understanding what went wrong if a build fails.

---

## buildspec.yml

My first build failed because, when setting up the CodeBuild we set it up to use a `buildspec.yml` file. A `buildspec.yml` file is needed because this is the step-by-step instruction manual. It goes through each phase in order - install, pre_build, build, then post_build - running the commands you've specified in each section. Without it, the codebuild doesnt know how to build.

The first two phases in my `buildspec.yml` file installs `java8`.

The third phase in my `buildspec.yml` file has the commands to run on `build` which is so echo/print the date of start and to compile the code based on `settings.xml`.

The fourth phase in my `buildspec.yml` file are the `post_build` commands, this echo/prints the date of build completion and packages the project.

![Image](http://learn.nextwork.org/merry_vermilion_zany_llama/uploads/aws-devops-codebuild-updated_35588a47)

---

## Success!

My second build also failed, but with a different error that said `COMMAND_EXECUTION_ERROR: Error while executing command: mvn -s settings.xml compile. Reason: exit status 1` To fix this I have to create a IAM role and assign it to AWS CodeBuild so it has access to AWS CodeArtifact.

To resolve the second error, I created a edited the role that was auto created for the codebuild and attached a policy which gives the AWS CodeBuild access to the AWS CodeArtifact, so that it can fetch the necessary packages mentioned in `settings.xml`. When i build my project again, I saw the success sign.

To verify the build, I checked my `S3` bucket. Seeing the artifact tells me the build succeeded.

![Image](http://learn.nextwork.org/merry_vermilion_zany_llama/uploads/aws-devops-codebuild-updated_d9cc6191)

---

## Automating Testing

In a project extension, I'm writing and including a test in the CI/CD pipeline. This test script checks is there a src folder and an index.jsp file in your project directory?

To add the testscript to the build process, I included a simple script in the buildspec.yml file which will check if the folder structure has a `src` folder and includes a `index.js` file. I pushed this to my repo and ran the build again which succeeded.

After pushing my code to GitHub, I ran the AWS CodeBuild. I could see the logs in my build logs

![Image](http://learn.nextwork.org/merry_vermilion_zany_llama/uploads/aws-devops-codebuild-updated_sm-test-script-upload)

---

---
